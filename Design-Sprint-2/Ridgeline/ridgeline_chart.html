<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ridgeline Chart — Subscription Type</title>
  <link rel="stylesheet" href="css/style.css">
  <style>
    .tooltip {
      position: absolute;
      padding: 8px 12px;
      background: rgba(245, 247, 245, 0.95);
      border: 1px solid #ddd;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      opacity: 0;
      color:#000000;
    }
    .value-dot {
      fill: white;
      stroke: #000000;
      stroke-width: 1.5;
      r: 4;
      opacity: 0;
      transition: opacity 0.2s;
    }
  </style>
</head>
<body>
  <header>
    <h1 class="title">Ridgeline — Distribution by Subscription Type</h1>
    <p class="subtitle">Compare the distribution of a numeric metric across <strong>subscription_type</strong>.</p>
  </header>

  <div class="container">
    <div class="controls">
      <label>Metric:
        <select id="metric">
          <option value="songs_played_per_day">songs_played_per_day</option>
          <option value="listening_time">listening_time</option>
        </select>
      </label>
      <button id="load">Load Data</button>
    </div>

    <div class="legend" id="legend"></div>
    <div class="chart-wrap">
      <svg id="chart" viewBox="0 0 1100 600" preserveAspectRatio="xMidYMid meet"></svg>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <script>
  // ---------- CONFIG ----------
  const CSV_FILE = 'spotify_new_data.csv';
  const ORDER = ["Free","Student","Family","Premium"];
  const COLORS = {
    Free: getComputedStyle(document.documentElement).getPropertyValue('--free').trim() || 'gray',
    Student: getComputedStyle(document.documentElement).getPropertyValue('--student').trim() || '#2cb1bc',
    Family: getComputedStyle(document.documentElement).getPropertyValue('--family').trim() || '#f4a261',
    Premium: getComputedStyle(document.documentElement).getPropertyValue('--premium').trim() || '#8a5cf6'
  };

  const svg = d3.select('#chart');
  const width = 1100, height = 600;
  const margin = {top: 40, right: 30, bottom: 50, left: 120};
  const innerW = width - margin.left - margin.right;
  const innerH = height - margin.top - margin.bottom;

  const g = svg.append('g').attr('transform', `translate(${margin.left},${margin.top})`);
  const gx = g.append('g').attr('class','axis axis--x').attr('transform', `translate(0,${innerH})`);
  const gy = g.append('g').attr('class','axis axis--y');
  const rule = g.append('line').attr('class','rule').style('display','none');

  // Create tooltip
  const tooltip = d3.select('body').append('div')
    .attr('class', 'tooltip')
    .style('opacity', 0);

  // Legend
  const legend = d3.select('#legend');
  Object.entries(COLORS).forEach(([k, c]) => {
    legend.append('span').html(`<span class="swatch" style="background:${c}"></span>${k}`);
  });

  // ---------- HELPERS ----------
  function epanechnikovKernel(bw) {
    return x => Math.abs(x /= bw) <= 1 ? 0.75 * (1 - x*x) / bw : 0;
  }
  
  function kde(kernel, X, domain, steps=80) {
    const [xmin, xmax] = domain;
    const x = d3.scaleLinear().domain([0, steps-1]).range([xmin, xmax]);
    return d3.range(steps).map(i => {
      const xi = x(i);
      const v = d3.mean(X, d => kernel(xi - d));
      return [xi, v || 0];
    });
  }
  
  function autoBandwidth(values) {
    const v = values.filter(Number.isFinite);
    const n = v.length; if (!n) return 1;
    const q1 = d3.quantile(v, 0.25), q3 = d3.quantile(v, 0.75);
    const iqr = (q3 - q1);
    const sigma = d3.deviation(v) || (iqr/1.34) || 1;
    return 1.06 * sigma * Math.pow(n, -1/5);
  }

  function toGroups(rows, metric) {
    const grouped = d3.group(rows, d => d.subscription_type);
    const keys = ORDER.filter(k => grouped.has(k));
    return keys.map(k => ({key: k, values: grouped.get(k)}));
  }

  // Find closest point in density curve for a given x value
  function findClosestPoint(density, xValue) {
    let minDistance = Infinity;
    let closestPoint = null;
    
    density.forEach(point => {
      const distance = Math.abs(point[0] - xValue);
      if (distance < minDistance) {
        minDistance = distance;
        closestPoint = point;
      }
    });
    
    return closestPoint;
  }

  // ---------- MAIN RENDER ----------
  async function render(metric) {
    try {
      const data = await d3.csv(CSV_FILE, d3.autoType);
      if (!data.length) throw new Error('CSV has no rows.');

      const groups = toGroups(data, metric);
      const allValues = groups.flatMap(g => g.values.map(d => +d[metric])).filter(Number.isFinite);
      const xDomain = d3.extent(allValues);

      // Clear previous chart
      g.selectAll('.ridge').remove();
      g.selectAll('.overlay').remove();
      g.selectAll('.value-dot').remove();

      // Axis scales
      const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerW]);
      const yBand = d3.scaleBand().domain(groups.map(d => d.key)).range([0, innerH]).paddingInner(0.5);

      // Compute densities per group
      const densities = groups.map(gp => {
        const vals = gp.values.map(d => +d[metric]).filter(Number.isFinite);
        const bw = autoBandwidth(vals);
        const dens = kde(epanechnikovKernel(bw), vals, x.domain(), 100);
        const ymax = d3.max(dens, d => d[1]) || 1;
        return { 
          key: gp.key, 
          density: dens, 
          ymax, 
          bw,
          rawValues: vals, // Store raw values for counting
          count: vals.length // Total count for this group
        };
      });
      
      const yScaleForRidge = d3.scaleLinear().domain([0, d3.max(densities, d => d.ymax)||1]).range([yBand.bandwidth(), 0]);

      // Axes
      gx.call(d3.axisBottom(x).ticks(8));
      gy.call(d3.axisLeft(yBand));

      // JOIN
      const ridge = g.selectAll('.ridge').data(densities, d => d.key);
      const ridgeEnter = ridge.enter().append('g').attr('class','ridge');

      ridgeEnter.merge(ridge)
        .attr('transform', d => `translate(0,${yBand(d.key)})`);

      // Area
      ridgeEnter.append('path').attr('class','ridge-area');
      ridge.select('.ridge-area').remove();
      ridgeEnter.append('path').attr('class','ridge-area');

      g.selectAll('.ridge')
        .data(densities, d => d.key)
        .select('.ridge-area')
        .attr('fill', d => COLORS[d.key] || 'steelblue')
        .attr('d', d => d3.area()
          .x(p => x(p[0]))
          .y0(yScaleForRidge(0))
          .y1(p => yScaleForRidge(p[1]))
          .curve(d3.curveCatmullRom.alpha(0.5))(d.density)
        );

      // Outline line
      g.selectAll('.ridge').select('.ridge-line').remove();
      g.selectAll('.ridge')
        .append('path')
        .attr('class','ridge-line')
        .attr('fill','none')
        .attr('stroke', d => d3.color(COLORS[d.key]).darker(0.4))
        .attr('d', d => d3.line()
          .x(p => x(p[0]))
          .y(p => yScaleForRidge(p[1]))
          .curve(d3.curveCatmullRom.alpha(0.5))(d.density)
        );

      // Create dots for value indicators (initially hidden)
      g.selectAll('.ridge')
        .append('circle')
        .attr('class', 'value-dot')
        .attr('fill', d => COLORS[d.key])
        .attr('stroke', d => d3.color(COLORS[d.key]).darker(0.6))
        .attr('stroke-width', 2)
        .attr('r', 5);

      // Mouse interaction: vertical rule with value display
      const overlay = g.selectAll('.overlay').data([null]).join('rect')
        .attr('class','overlay')
        .attr('x', 0).attr('y', 0)
        .attr('width', innerW).attr('height', innerH)
        .attr('fill','transparent')
        .on('mousemove', (event) => {
          const [mx] = d3.pointer(event);
          const xValue = x.invert(mx);
          
          // Show vertical rule
          rule.style('display', null)
              .attr('x1', mx).attr('x2', mx)
              .attr('y1', 0).attr('y2', innerH);
          
          // Update dots and tooltip
          let tooltipHTML = `<strong>Value: ${xValue.toFixed(2)}</strong><br>`;
          let totalDensity = 0;
          
          densities.forEach((d, i) => {
            const closestPoint = findClosestPoint(d.density, xValue);
            if (closestPoint) {
              const densityValue = closestPoint[1];
              const yPos = yScaleForRidge(densityValue);
              const groupY = yBand(d.key);
              
              // Update dot position
              g.selectAll('.ridge').filter(ridge => ridge.key === d.key)
                .select('.value-dot')
                .attr('cx', x(closestPoint[0]))
                .attr('cy', yPos)
                .style('opacity', densityValue > 0 ? 1 : 0);
              
              // Add to tooltip
              const percentage = (densityValue / d.ymax * 100).toFixed(1);
              tooltipHTML += `<span style="color:${COLORS[d.key]}">●</span> ${d.key}: ${densityValue.toFixed(4)} (${percentage}% of max)<br>`;
              totalDensity += densityValue;
            }
          });
          
          
          
          // Position and show tooltip
          tooltip
            .html(tooltipHTML)
            .style('left', (event.pageX + 15) + 'px')
            .style('top', (event.pageY - 28) + 'px')
            .style('opacity', 100);
            
        })
        .on('mouseleave', () => {
          rule.style('display','none');
          tooltip.style('opacity', 0);
          g.selectAll('.value-dot').style('opacity', 0);
        });

    } catch (error) {
      console.error('Error loading or rendering data:', error);
      alert('Error: ' + error.message);
    }
  }

  // Wire controls
  const $metric = document.getElementById('metric');
  const $load = document.getElementById('load');

  $metric.addEventListener('change', () => render($metric.value));
  $load.addEventListener('click', () => render($metric.value));

  // Auto-load on page load
  document.addEventListener('DOMContentLoaded', () => {
    render($metric.value);
  });
  </script>
</body>
</html>